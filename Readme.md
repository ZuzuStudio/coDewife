# coDewife
Суперхуткі і суперакуратны фарматар коду, навядзе парадак як ваша маці ^_^

## Version history

* v0.2.0 базавыя выходныя тэрмы

* v0.1.0 базавыя прадукцыйныя машыны і іх канфігурацыі.

* v0.0.0 пачатак распрацоўкі

## Ідэі

- [ ] Існуе 2 пераўтварацеля: першы з зыходнага коду ў масіў структур, другі з масіва струтур у зыходны код

- [ ] Структура звязана з трыгерам, які аб'яўлены у файле канфігурацый.

- [ ] Мадулірызацыя: рэбры паміж станамі выкарыстоўваюць аўтамат для распазнавання і пераутварэння

- [ ] Рэбры бываюць розных кшталтаў: звычайныя (змяняюць пазіцыю і дапісваюць выходныя тэрмы), квазі (рэагуюць на преаход, 
але не змяняюць нічога) і рэверсіўныя (не змяняюць пазіцыі але дапісваюць тэрмы)

- [ ] Ёсць тры кшталту станаў: звычайны, добры краш і благі краш. Пры пераходзе у добры краш аўтамат звяртае праўду і змяняе
пазіцыю і выходныя тэрмы, пры пераходзе у благі крэш звяртаецца хлусня і нічога не змяняецца.

- [ ] Існуюць два напрамкі працы аўтаматаў і рэбраў: прамы і зваротны.

- [ ] Складаныя аўтаматы ствараюцца праз канфігурацыі (паслядоўную, паралельную, розныя кванціфікатары, "туды-сюды")

- [ ] Выходныя тэрмы апісваюцца у асобным файле json. Прасцейшыя альбо роста вяртаюць радок, альбо вяртаюць радок у залежнасці ад статычнага булевага поля. Больш складаныя магчыма маюць у сабе лічыльнік напрыклад, колькі пазіцый займае тэкст перад імі.

- [ ] Існуе яшчэ трэці json у якім распісаны опцыі і з якімі выходнымі тэрмамі яны звязаны.
 
- [ ] Опцыі ёсць камбінацыя бінарных трыгераў, самі трыгеры захоўваюцца у асобным джосане

- [ ] Ёсць від выходных тэрмаў, які захоўвае ў сабе масіў спасылак на пэўную колькасць папярэдніх тэрмаў
 
- [ ] Папярэднія тэрмы накопліваюцца у стэку

- [ ] Выходныя тэрмы нясуць інфармацыю колькі знакаў яны займаюць

- [ ] Спачатку увесь код апрацоўваецца ў выходныя тэрмы інварыянты, а потым на ніх запускаецца падабенстава машыны Т'юрынга якая перапрацоўвае іх у іншыю пасслядоўнасць Трэба прыдумаць сродкі фармалізацыі і мадулярызацыі.

- [ ] Для распознавания токенов запускать все алгоритмы распознавания (втекущей версии автоматы). В процессе накопления символов алгоритмы будут или продолжать работать, или прекратят свою работу с ошибкой. Тип токена определяется по типу алгоритма, который последним распознавал последовательность символов.
#### Пример:
Для определённости рассмотрим язык, в котором присутствует ключевое слово for, а каждый идентификатор - это последовательность букв латинского алфавита.

##### I шаг

... formula ...
    ^
1-й алгоритм распознаёт ключевые слова
2-й алгоритм распознаёт идентификаторы

1) продолжает свою работу (f совпадает с началом ключевого слова for)
2) продолжает работу, так как f - это буква латинского алфавита

##### II шаг

... formula ...
    ^^
1) продолжает свою работу (fo совпадает с началом ключевого слова for)
2) продолжает работу, так как fo - это последовательность букв латинского алфавита

##### III шаг

... formula ...
    ^^^
1) продолжает свою работу (for совпадает с ключевым словом for)
2) продолжает работу, так как for - это последовательность букв латинского алфавита

##### IV шаг

... formula ...
    ^^^^
1) заканчивает свою работу с ошибкой (form не совпадает с ключевым словом for)
2) продолжает работу, так как form - это последовательность букв латинского алфавита

...

##### VIII шаг

... formula ...
    ^^^^^^^^
1) закончил свою работу на IV шаге
2) заканчивает свою работу с ошибкой, так как formula_ (с пробелом на конце) - это не последовательность букв латинского алфавита

Поскольку больше не осталось алгоритмов, распознающих последовательность текста, а "Идентификатор" был последним алгоритмом, то formula интерпретируется, как идентификатор.
